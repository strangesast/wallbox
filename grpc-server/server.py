import os
import re
import asyncio

from grpclib.utils import graceful_exit
from grpclib.server import Server

# generated by protoc
from wallbox_pb2 import Status
from wallbox_grpc import WallboxBase

MPD_HOST = os.environ.get('MPD_HOST') or 'localhost'
MPD_PORT = os.environ.get('MPD_PORT') or '6600'

version_re = re.compile('OK MPD (?P<version>[\d.]+)')


async def worker(queue):
    reader, writer = await asyncio.open_connection(MPD_HOST, MPD_PORT)

    data = await reader.read(1000000)
    version = version_re.search(data.decode()).group(1)
    print(f'mpd version: {version}')

    while True:
        command, fut = await queue.get()
        writer.write(command.encode())
        data = await reader.read(1000000)
        fut.set_result(data)
        queue.task_done()



async def get_status(request):
    #name = request.match_info.get('name', "Anonymous")
    response = await do_command('status\n')

    response = response.split('\n')
    if response[-1] != '' or response[-2] != 'OK':
        raise ValueError('unexpected response!')

    response = {a: b.strip() for p in response[0:-2] for (a, b) in [p.split(':', 1)]}
    return web.json_response(response)


class Wallbox(WallboxBase):
    def __init__(self, queue):
        self.queue = queue


    async def GetStatus(self, stream):
        await stream.recv_message()

        response = await self.do_command('status\n')
    
        response = response.split('\n')
        if response[-1] != '' or response[-2] != 'OK':
            raise ValueError('unexpected response!')

        response = {a: b.strip() for p in response[0:-2]
                for (a, b) in [p.split(':', 1)]}

        for key in ['volume', 'repeat', 'random', 'consume', 'playlist', 'playlistlength', 'song', 'songid', 'nextsong', 'nextsongid', 'time', 'elapsed', 'duration', 'bitrate', 'xfade']:
            if key in response:
                response[key] = int(response[key])

        for key in ['mixrampdb', 'mixrampdelay']:
            if key in response:
                response[key] = float(response[key])
 
        await stream.send_message(Status(**response))


    async def do_command(self, command: str) -> str:
        if not command.endswith('\n'):
            raise Exception('invalid command (does not end with newline)')
        fut = asyncio.get_running_loop().create_future()
        self.queue.put_nowait((command, fut))
        response = await fut
        return response.decode()


async def main(*, host='0.0.0.0', port=50051):
    queue = asyncio.Queue()
    server = Server([Wallbox(queue)])

    loop = asyncio.get_running_loop()
    task = loop.create_task(worker(queue))

    with graceful_exit([server]):
        await server.start(host, port)
        print(f'Serving on {host}:{port}')
        await server.wait_closed()

    await task



if __name__ == '__main__':
    asyncio.run(main())
