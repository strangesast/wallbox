import os
import re
import asyncio

from grpclib.utils import graceful_exit
from grpclib.server import Server

# generated by protoc
from wallbox_pb2 import Status
from wallbox_grpc import WallboxBase

MPD_HOST = os.environ.get('MPD_HOST') or 'localhost'
MPD_PORT = os.environ.get('MPD_PORT') or '6600'

version_re = re.compile('OK MPD (?P<version>[\d.]+)')


async def get_connection():
    while True:
        response = None
        async with asyncio.connect(MPD_HOST, MPD_PORT) as stream:
            data = await stream.read(100000)
            if not data:
                break
            version = version_re.search(data.decode())
            if not version:
                break
            response = version.group(1)

            print(f'mpd version {response}')

            while response:
                command = yield response
                await stream.write(command.encode())
                data = await stream.read(1000000)
                print('got data', data)
                response = data.decode()



async def worker(queue):
    g = get_connection()
    await g.asend(None)
    while True:
        command, fut = await queue.get()
        response = await g.asend(command)
        fut.set_result(response)
        queue.task_done()



class Wallbox(WallboxBase):
    def __init__(self, queue):
        self.queue = queue


    async def GetListFiles(self, stream):
        request: Uri = await stream.recv_message()
        print('GetListFiles', request)
        items = [FileListItem(uri=f'/{i}', name=f'Song File {i}', type='file', size=1000) for i in range(10)]
        await stream.send_message(FileListResult(items=items, count=len(items)))

    async def GetPlaylistInfo(self, stream):
        request: PositionRange = await stream.recv_message()
        print('GetPlaylistInfo', request)
        items = [PlaylistItem(position=i, uri=f'/{i}', songName=f'Song File {i}') for i in range(10)]
        await stream.send_message(PlaylistInfoResult(items=items, count=len(items), offset=0))

    async def GetStatus(self, stream):
        await stream.recv_message()

        response = await self.do_command('status\n')
        print('response', response)
    
        response = response.split('\n')
        if response[-1] != '' or response[-2] != 'OK':
            raise ValueError('unexpected response!')

        response = {a: b.strip() for p in response[0:-2]
                for (a, b) in [p.split(':', 1)]}

        for key in ['volume', 'repeat', 'random', 'consume', 'playlist', 'playlistlength', 'song', 'songid', 'nextsong', 'nextsongid', 'time', 'elapsed', 'duration', 'bitrate', 'xfade']:
            if key in response:
                response[key] = int(response[key])

        for key in ['mixrampdb', 'mixrampdelay']:
            if key in response:
                response[key] = float(response[key])
 
        await stream.send_message(Status(**response))


    async def do_command(self, command: str) -> str:
        if not command.endswith('\n'):
            raise Exception('invalid command (does not end with newline)')
        fut = asyncio.get_running_loop().create_future()
        self.queue.put_nowait((command, fut))
        response = await fut
        return response


async def main(*, host='0.0.0.0', port=50051):
    queue = asyncio.Queue()
    server = Server([Wallbox(queue)])

    loop = asyncio.get_running_loop()
    task = loop.create_task(worker(queue))

    with graceful_exit([server]):
        await server.start(host, port)
        print(f'Serving on {host}:{port}')
        await server.wait_closed()

    await task



if __name__ == '__main__':
    asyncio.run(main())
