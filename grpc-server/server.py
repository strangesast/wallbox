import os
import re
import asyncio
from datetime import datetime

from grpclib.utils import graceful_exit
from grpclib.server import Server
from google.protobuf.timestamp_pb2 import Timestamp

# generated by protoc
import wallbox_pb2 as pb2
from wallbox_grpc import WallboxBase

MPD_HOST = os.environ.get('MPD_HOST') or 'localhost'
MPD_PORT = os.environ.get('MPD_PORT') or '6600'

version_re = re.compile('OK MPD (?P<version>[\d.]+)')

#def datetime_from_timestamp(timestamp: Timestamp) -> datetime:
#    return datetime.fromtimestamp(timestamp.seconds + timestamp.nanos/1e9)
# or
# timestamp.ToDatetime()

def timestamp_from_str(s):        
  return Timestamp().FromDatetime(datetime.strptime(s, '%Y-%m-%dT%H:%M:%SZ'))

async def get_connection():
    command = None
    retry = 0
    while True:
        response = None
        print('connecting... ({}, {})'.format(MPD_HOST, MPD_PORT))
        async with asyncio.connect(MPD_HOST, MPD_PORT) as stream:
            print('got connection')
            data = await stream.read(100000)
            response = data and (version := version_re.search(data.decode())) and version.group(1) or None

            print(f'mpd version {response}')

            while response:
                if command is None:
                    command = yield response
                await stream.write(command.encode())
                data = await stream.read(1000000)
                print('got data', data)
                if not data:
                    retry += 1
                    break
                retry = 0
                response = data.decode()
                command = None


async def worker(queue):
    while True:
        command, fut = await queue.get()
        print('got command, waiting for connection: {}:{}'.format(MPD_HOST, MPD_PORT))
        try:
            async with asyncio.connect(MPD_HOST, MPD_PORT) as stream:
                data = await stream.read(100000)
                response = data and (version := version_re.search(data.decode())) and version.group(1) or None
                print(f'mpd version {response}')

                await stream.write(command.encode())
                data = await stream.read(1000000)
                response = data.decode()

                fut.set_result(response)
                queue.task_done()
        finally:
            print('connection over')


response_re = re.compile('(?P<end>OK$)|((?P<key>[\w -]+): (?P<value>[\w\S ]+)$)', re.M)

def parse_response(response, value_types_dict):
    args = {}
    end = False
    for match in response_re.finditer(response):
        if match.group('end'):
            end = True
        else:
            key, value = match.group('key'), match.group('value')
            t = value_types_dict.get(key)
            if t is None:
                raise Exception(f'unexpected response unknown key "{key}"')
            args[key] = t(value)

    if not end:
        raise Exception('unexpected response. no termination')

    return args


class Wallbox(WallboxBase):
    def __init__(self, queue):
        self.queue = queue

    async def CurrentSong(self, stream):
        pass

    async def DatabaseListFiles(self, stream):
        request: Uri = await stream.recv_message()
        uri = request.uri
        command_response = await self.do_command('listfiles "{}"\n'.format(uri))
        def parse_array_response(text):
            last = None
            for match in response_re.finditer(text):
                if match.group('end'):
                    if last:
                        yield last
                    return
                else:
                    key, value = match.group('key'), match.group('value')
                    if key == 'file' or key == 'directory':
                        if last:
                            yield last
                        last = {'type': key, 'name': value, 'uri': f'{uri}/{value}' if uri != '' else value}
                    elif key == 'size':
                        last['size'] = int(value)
                    elif key == 'Last-Modified':
                        last['lastModified'] = timestamp_from_str(value)
                    else:
                        raise Exception('unrecognized key ({})'.format(key))
        items = [pb2.FileListResult.FileListItem(**args) for args in parse_array_response(command_response)]
        response = pb2.FileListResult(items=items, count=len(items))
        await stream.send_message(response)

    async def PlaybackNext(self, stream):
        pass

    async def PlaybackPause(self, stream):
        pass

    async def PlaybackPrevious(self, stream):
        pass

    async def PlaybackStop(self, stream):
        pass

    async def QueueAdd(self, stream):
        pass

    async def QueueAddId(self, stream):
        pass

    async def QueuePlaylistFind(self, stream):
        pass

    async def QueuePlaylistId(self, stream):
        pass

    async def QueueAddTagId(self, stream):
        pass

    async def QueueDelete(self, stream):
        pass

    async def QueueClear(self, stream):
        pass

    async def QueueClearTagId(self, stream):
        pass

    async def QueueDeleteId(self, stream):
        pass

    async def QueueMove(self, stream):
        pass

    async def QueueMoveId(self, stream):
        pass

    async def QueuePlaylistChanges(self, stream):
        pass

    async def QueuePlaylistChangesPosId(self, stream):
        pass


    PLAYLIST_ITEM_TYPES = {
        'file': (str, 'filename'),
        'Last-Modified': (lambda s: Timestamp().FromDatetime(datetime.strptime(s, '%Y-%m-%dT%H:%M:%SZ')), 'lastModified'),
        'Artist': (str, 'artist'),
        'Title': (str, 'title'),
        'Album': (str, 'album'),
        'Track': (int, 'track'),
        'Date': (str, 'date'),
        'Genre': (str, 'genre'),
        'Time': (int, 'time'),
        'duration': (float, 'duration'),
        'Pos': (int, 'position'),
        'Id': (int, 'id'),
    }
    async def QueuePlaylistInfo(self, stream):
        query = await stream.recv_message() # PositionRange
        response = await self.do_command('playlistinfo\n')
        def handle(text):
            last = None
            for match in response_re.finditer(response):
                if match.group('end'):
                    if last:
                        yield pb2.PlaylistResult.PlaylistItem(**last)
                    return
                key, value = match.group('key'), match.group('value')
                if key == 'file' or key == 'directory':
                    if last:
                        yield pb2.PlaylistResult.PlaylistItem(**last)
                    last = {}

                if last is None:
                    raise Exception('unexpected response. key out of order')
                if (v := self.PLAYLIST_ITEM_TYPES.get(key)) is None:
                    print(f'warning: unexpected response key: "{key}"')
                    continue
                    #raise Exception(f'unexpected response unknown key "{key}"')
                t, akey = v
                last[akey] = t(value)
        items = list(handle(response))
        result = pb2.PlaylistResult(items=items, count=len(items), offset=0)
        #args = parse_response(response, self.STATUS_TYPES)
        await stream.send_message(result)

    async def QueuePlaylistSearch(self, stream):
        pass

    async def QueuePriority(self, stream):
        pass

    async def QueueRangeId(self, stream):
        pass

    async def QueueShuffle(self, stream):
        pass

    async def QueueSwap(self, stream):
        pass

    async def QueueSwapId(self, stream):
        pass

    STATS_TYPES = {
        'artists': int,
        'albums': int,
        'songs': int,
        'uptime': int,
        'db_playtime': int,
        'db_update': int,
        'playtime': int,
    }
    async def Stats(self, stream):
        await stream.recv_message() # Empty
        response = await self.do_command('stats\n')
        args = parse_response(response, self.STATS_TYPES)
        await stream.send_message(pb2.StatsResult(**args))


    STATUS_TYPES = {
        'volume': int,
        'repeat': int,
        'random': int,
        'single': int,
        'consume': int,
        'playlist': int,
        'playlistlength': int,
        'song': int,
        'songid': int,
        'nextsong': int,
        'nextsongid': int,
        'time': int,
        'elapsed': int,
        'duration': int,
        'bitrate': int,
        'xfade': int,
        'mixrampdb': float,
        'mixrampdelay': float,
        'state': str,
        'audio': str,
        'updating_db': str,
        'error': str,
    }
    async def Status(self, stream):
        await stream.recv_message() # Empty
        response = await self.do_command('status\n')
        args = parse_response(response, self.STATUS_TYPES)
        await stream.send_message(pb2.StatusResult(**args))


    async def GetListFiles(self, stream):
        request: Uri = await stream.recv_message()
        print('GetListFiles', request)
        items = [FileListItem(uri=f'/{i}', name=f'Song File {i}', type='file', size=1000) for i in range(10)]
        await stream.send_message(FileListResult(items=items, count=len(items)))

    async def GetPlaylistInfo(self, stream):
        request: PositionRange = await stream.recv_message()
        print('GetPlaylistInfo', request)
        items = [PlaylistItem(position=i, uri=f'/{i}', songName=f'Song File {i}') for i in range(10)]
        await stream.send_message(PlaylistInfoResult(items=items, count=len(items), offset=0))

    async def do_command(self, command: str) -> str:
        if not command.endswith('\n'):
            raise Exception('invalid command (does not end with newline)')
        print('making request')
        fut = asyncio.get_running_loop().create_future()
        self.queue.put_nowait((command, fut))
        print('waiting')
        response = await fut
        print('done!')
        return response


async def main(*, host='0.0.0.0', port=50051):
    queue = asyncio.Queue()
    server = Server([Wallbox(queue)])

    loop = asyncio.get_running_loop()
    task = loop.create_task(worker(queue))

    with graceful_exit([server]):
        await server.start(host, port)
        print(f'Serving on {host}:{port}')
        await server.wait_closed()

    await task



if __name__ == '__main__':
    asyncio.run(main())
